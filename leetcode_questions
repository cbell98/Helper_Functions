# Closest pair to target among 2 arrays:

a1 = [-1, 3, 8, 2, 9, 5, 7, 12, 18, -6, 11]
a2 = [4, 1, 2, 10, 5, 20, 22, -7, 33, 19, 6]
target = 18

def closestPair(a1: list, a2: list, target: int) -> list:

    goal = target
    loss = 1000

    for num in a1:
        
        for digit in a2:
            sum = num + digit
            diff = abs(sum - goal)
            if diff == 0:
                return num, digit
            else:
                if diff < loss:
                    loss = diff
                    closest_num = num
                    closest_digit = digit
                    
    return closest_num, closest_digit

closestPair(a1, a2, target)



def factorial(n):

    if n >= 1:
        return n * factorial(n-1)
    else:
        return 1

factorial(8)



def fib(n):

    if n >= 3:
        return fib(n-1) + fib(n-2)
        
    else:
        return 1

fib(3)



You are given the root of a binary search tree (BST) and an integer val. Find the node in the BST that the node's value equals val 
and return the subtree rooted with that node. If such a node does not exist, return null.
class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        
        stack = [root]
        
        while stack != []:
            root = stack.pop()
            if root.val == val:
                return root
            
            if root.right is not None:
                stack.append(root.right)
            if root.left is not None:
                stack.append(root.left)
        
        return None
   
   
Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.
A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.

class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        
        def helper(l, r):
            if l > r:
                return None
            
            m = (l + r) // 2
            root = TreeNode(nums[m])
            root.left = helper(l, m - 1)
            root.right = helper(m + 1, r)
            return root
        
        return helper(0, len(nums) - 1)
        
